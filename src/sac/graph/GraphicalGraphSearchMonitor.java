package sac.graph;

import java.io.File;
import java.io.IOException;

import org.jfree.chart.ChartFrame;
import org.jfree.chart.ChartUtilities;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.axis.NumberAxis;
import org.jfree.chart.plot.CombinedDomainXYPlot;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.chart.plot.XYPlot;
import org.jfree.chart.renderer.xy.XYItemRenderer;
import org.jfree.chart.renderer.xy.XYLineAndShapeRenderer;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

import sac.util.ConsoleLogger;

/**
 * Implementation of monitor with graphical charts as output (charts generated by jfreechart software,
 * http://www.jfree.org/jfreechart/).
 * 
 * @author Marcin Korzeń (<a href="mailto:mkorzen@wi.zut.edu.pl">wi.zut.edu.pl</a>)
 * @author Przemysław Klęsk (<a href="mailto:pklesk@wi.zut.edu.pl">wi.zut.edu.pl</a>)
 */

public class GraphicalGraphSearchMonitor extends GraphSearchMonitor {

	/**
	 * Width of plot frame.
	 */
	private static int FRAME_WIDTH = 1280;

	/**
	 * Height of plot frame.
	 */
	private static int FRAME_HEIGHT = 640;

	/**
	 * Gap between plots.
	 */
	private static double GAP_BETWEEN_PLOTS = 5.0;

	/**
	 * Plot series for: number of solutions found so far.
	 */
	private XYSeries solutionsSoFar;

	/**
	 * Plot series for: best state's value of h function.
	 */
	private XYSeries bestSoFarH;

	/**
	 * Plot series for: best state's value of f function.
	 */
	private XYSeries bestSoFarF;

	/**
	 * Plot series for: best state's depth.
	 */
	private XYSeries bestSoFarDepth;

	/**
	 * Plot series for: current state's value of h function.
	 */
	private XYSeries currentH;

	/**
	 * Plot series for: current state's value of f function.
	 */
	private XYSeries currentF;

	/**
	 * Plot series for: current state's depth.
	 */
	private XYSeries currentDepth;

	/**
	 * Plot series for: number of closed states.
	 */
	private XYSeries closedSize;

	/**
	 * Plot series for: number of open states.
	 */
	private XYSeries openSize;

	/**
	 * Plot series for: free memory.
	 */
	private XYSeries freeMemory;

	/**
	 * Plot series for: used memory.
	 */
	private XYSeries usedMemory;

	/**
	 * Plot series for: maximum memory.
	 */
	private XYSeries maxMemory;

	/**
	 * Plot collection for: scores.
	 */
	private XYSeriesCollection collectionScores;

	/**
	 * Plot collection for: closed, open states.
	 */
	private XYSeriesCollection collectionCO;

	/**
	 * Plot collection for: JVM memory.
	 */
	private XYSeriesCollection collectionJVM;

	/**
	 * Frame object.
	 */
	private ChartFrame frame;

	/**
	 * Chart object.
	 */
	private JFreeChart chart;

	/**
	 * Creates new instance of graphical graph search monitor.
	 * 
	 * @param algorithm reference to graph search algorithm
	 * @param refreshTime refresh time
	 */
	public GraphicalGraphSearchMonitor(GraphSearchAlgorithm algorithm, long refreshTime) {
		super(algorithm, refreshTime);

		solutionsSoFar = new XYSeries("solutions so far");
		bestSoFarH = new XYSeries("best's h");
		bestSoFarF = new XYSeries("best's f");
		bestSoFarDepth = new XYSeries("best's depth");
		currentH = new XYSeries("current's h");
		currentF = new XYSeries("current's f");
		currentDepth = new XYSeries("current's depth");

		closedSize = new XYSeries("closed");
		openSize = new XYSeries("open");

		freeMemory = new XYSeries("free memory");
		usedMemory = new XYSeries("used memory");
		maxMemory = new XYSeries("max memory");

		collectionScores = new XYSeriesCollection();
		collectionScores.addSeries(solutionsSoFar);
		collectionScores.addSeries(bestSoFarH);
		collectionScores.addSeries(bestSoFarF);
		collectionScores.addSeries(bestSoFarDepth);
		collectionScores.addSeries(currentH);
		collectionScores.addSeries(currentF);
		collectionScores.addSeries(currentDepth);

		collectionCO = new XYSeriesCollection();
		collectionCO.addSeries(closedSize);
		collectionCO.addSeries(openSize);

		collectionJVM = new XYSeriesCollection();
		collectionJVM.addSeries(freeMemory);
		collectionJVM.addSeries(usedMemory);
		collectionJVM.addSeries(maxMemory);

		makeChart();
	}

	/**
	 * Makes the chart.
	 */
	private void makeChart() {
		XYItemRenderer renderer1 = new XYLineAndShapeRenderer(true, true);
		XYItemRenderer renderer2 = new XYLineAndShapeRenderer(true, true);
		XYItemRenderer renderer3 = new XYLineAndShapeRenderer(true, true);
		renderer3.setBaseSeriesVisibleInLegend(true);
		renderer3.setBaseItemLabelsVisible(true);
		NumberAxis rangeAxis1 = new NumberAxis("scores");
		NumberAxis rangeAxis2 = new NumberAxis("closed, open states");
		NumberAxis rangeAxis3 = new NumberAxis("JVM memory [B]");

		XYPlot subplot1 = new XYPlot(collectionScores, null, rangeAxis1, renderer1);
		XYPlot subplot2 = new XYPlot(collectionCO, null, rangeAxis2, renderer2);
		XYPlot subplot3 = new XYPlot(collectionJVM, null, rangeAxis3, renderer3);

		CombinedDomainXYPlot plot = new CombinedDomainXYPlot(new NumberAxis("Time [s]"));
		plot.setGap(GAP_BETWEEN_PLOTS);
		// adding subplots
		plot.add(subplot1, 1);
		plot.add(subplot2, 1);
		plot.add(subplot3, 1);
		plot.setOrientation(PlotOrientation.VERTICAL);
		chart = new JFreeChart("GRAPHICAL GRAPH SEARCH MONITOR", JFreeChart.DEFAULT_TITLE_FONT, plot, true);

		frame = new ChartFrame(this.getClass().getCanonicalName(), chart);
		frame.setSize(FRAME_WIDTH, FRAME_HEIGHT);
		frame.setVisible(true);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see sac.graph.GraphSearchMonitor#printCurrentSummary()
	 */
	@Override
	public synchronized void printCurrentSummary() {
		ConsoleLogger.info("*** Starting " + this.getClass().getName() + ".printCurrentSummary():");

		double time = 0.001 * getTime();

		ConsoleLogger.info("Time: " + time + " s.");
		ConsoleLogger.info("Solutions so far: " + algorithm.getSolutions().size() + ".");
		ConsoleLogger.info("Closed states: " + algorithm.getClosedStatesCount() + ".");
		ConsoleLogger.info("Open states: " + algorithm.getOpenSet().size() + ".");

		GraphState bestSoFar = algorithm.getBestSoFar();
		if (bestSoFar != null) {
			ConsoleLogger.info("Best state's h: " + bestSoFar.getH() + ".");
			ConsoleLogger.info("Best state's f: " + bestSoFar.getF() + ".");
			ConsoleLogger.info("Best state's depth: " + bestSoFar.getDepth() + ".");

			bestSoFarH.addOrUpdate(time, bestSoFar.getH());
			bestSoFarF.addOrUpdate(time, bestSoFar.getF());
			bestSoFarDepth.addOrUpdate(time, bestSoFar.getDepth());
		}

		GraphState current = algorithm.getCurrent();
		if (current != null) {
			if (bestSoFar != null) {
				ConsoleLogger.info("Current state's h: " + current.getH() + ".");
				currentH.addOrUpdate(time, current.getH());
			}
			ConsoleLogger.info("Current state's f: " + current.getF() + ".");
			ConsoleLogger.info("Current state's depth: " + current.getDepth() + ".");
			currentF.addOrUpdate(time, current.getF());
			currentDepth.addOrUpdate(time, current.getDepth());
		}

		ConsoleLogger.info("Free memory: " + Runtime.getRuntime().freeMemory());
		ConsoleLogger.info("Used memory: " + Runtime.getRuntime().totalMemory());
		ConsoleLogger.info("Max memory: " + Runtime.getRuntime().maxMemory());

		closedSize.addOrUpdate(time, algorithm.getClosedStatesCount());
		openSize.addOrUpdate(time, algorithm.getOpenSet().size());
		solutionsSoFar.addOrUpdate(time, algorithm.getSolutions().size());

		if (current != null) {
			ConsoleLogger.info("Current state's f: " + current.getF() + ".");
			ConsoleLogger.info("Current state's depth: " + current.getDepth() + ".");
		}

		freeMemory.addOrUpdate(time, Runtime.getRuntime().freeMemory());
		usedMemory.addOrUpdate(time, Runtime.getRuntime().totalMemory());
		maxMemory.addOrUpdate(time, Runtime.getRuntime().maxMemory());

		ConsoleLogger.info("*** Done " + this.getClass().getName() + ".printCurrentSummary().");
	}

	/**
	 * Stops monitor and saves monitor's last image to file ./graphical_graph_search_monitor.jpg.
	 */
	public synchronized void stop() {
		super.stop();
		try {
			frame.setVisible(true);
			Thread.sleep(100);
			ChartUtilities.saveChartAsJPEG(new File("./graphical_graph_search_monitor.jpg"), chart, frame.getSize().width, frame.getSize().height);
			frame.dispose();
		} catch (IOException e) {
			String message = "Problem occurred creating chart.";
			ConsoleLogger.info(message);
			System.err.println(message);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}